import Head from "next/head";
import Header from "../components/Header";
import Image from "next/image";
import styled from "styled-components";
import Navigation from "../components/Navigation";
import TeamComponent from "../components/TeamComponent";
import { useEffect, useState } from "react";
import { Match, Team } from "../interfaces/interfaces";
import createAutomatedTournament from "../utils/createAutomatedTournament";
import getAllTeams from "../utils/getAllTeams";
import { nanoid } from "nanoid";
import postRound from "../utils/postRound";
import getRounds from "../utils/getRounds";

type TournamentProps = {
  rounds: any[][];
  setRounds: Function;
};

export default function Tournament({ rounds, setRounds }: TournamentProps) {
  const [isClicked, setIsClicked] = useState(false);
  const [nextRoundTeams, setNextRoundTeams] = useState<Team[]>([]);

  function handleClick() {
    setIsClicked(!isClicked);
  }

  async function handleUpdateScoreInDB(e: any) {
    e.stopPropagation();
    const updatedTournament = { name: "Goldbach", rounds: rounds };

    await fetch("api/tournaments/Goldbach", {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(updatedTournament),
    });
  }

  function handleDetermineWinner(e: any, match: Match) {
    e.stopPropagation();

    if (match.team1.points > match.team2.points) {
      const team1 = { ...match.team1, points: 0 };
      const updatedMatch = [...nextRoundTeams, team1];
      setNextRoundTeams(updatedMatch);
    } else {
      const team2 = { ...match.team2, points: 0 };
      const updatedMatch = [...nextRoundTeams, team2];
      setNextRoundTeams(updatedMatch);
    }
  }

  useEffect(() => {
    async function createTournamentAndManageDatabank() {
      const teams = await getAllTeams();
      if ((teams.length / 2) % 2 === 0) {
        const matchList = createAutomatedTournament(teams);
        setRounds([matchList]);
        postRound([matchList], "Goldbach");
      }
      console.log();
    }

    async function manageGetRounds() {
      const DBRounds = await getRounds();
      if (!DBRounds) {
        createTournamentAndManageDatabank();
      } else {
        setRounds(DBRounds);
      }
    }

    manageGetRounds();
  }, []);

  useEffect(() => {
    async function updateRoundsInDB(rounds: any[][]) {
      const updatedTournament = { name: "Goldbach", rounds: rounds };

      await fetch("api/tournaments/Goldbach", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(updatedTournament),
      });
    }
    function createNextRoundMatches(teams: Team[]) {
      let matches = [];

      for (let i = 0; i < teams.length; i += 2) {
        const match = {
          team1: teams[i],
          team2: teams[i + 1],
          id: nanoid(),
          winner: "",
        };
        matches.push(match);
      }
      return matches;
    }
    if (
      rounds.length > 0 &&
      nextRoundTeams.length === rounds[rounds.length - 1].length
    ) {
      const nextRoundMatches = createNextRoundMatches(nextRoundTeams);
      const updatedRounds = [...rounds, nextRoundMatches];
      setRounds(updatedRounds);
      setNextRoundTeams([]);
      updateRoundsInDB(updatedRounds);
      console.log("werden die neue matches angezeigt?");
    }
  }, [nextRoundTeams, rounds]);

  return (
    <StyledDiv>
      <Head>
        <title>MatchBall</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      {/* <Image
        src={"/playergroup.jpg"}
        alt={"Player group background image"}
        fill={true}
        objectFit={"cover"}
        objectPosition={"center"}
        style={{ position: "absolute", zIndex: -1 }}
      /> */}
      <Header teaser={"Games"} />
      <StyledMatchWrapperSection>
        {rounds.length > 0 && rounds ? (
          rounds.map((round: any) => {
            return (
              <StyledUl data-cy="match-list" key={nanoid()}>
                {round.map((match: Match, index: number) => {
                  return (
                    <StyledMatch key={match.id} onClick={handleClick}>
                      <StyledP>Spiel {index + 1}</StyledP>
                      <TeamComponent team={match.team1} isClickable={true} />
                      <StyledP>gegen</StyledP>
                      <TeamComponent team={match.team2} isClickable={true} />
                      {isClicked &&
                        match.team1.points &&
                        match.team2.points && (
                          <button
                            onClick={(e) => {
                              handleDetermineWinner(e, match);
                              handleUpdateScoreInDB(e);
                            }}
                          >
                            Best√§tigen
                          </button>
                        )}
                    </StyledMatch>
                  );
                })}
              </StyledUl>
            );
          })
        ) : (
          <p>
            Die Nummer der Mannschaften geteilt durch zwei muss gerade sein, um
            ein Turnier zu erstellen
          </p>
        )}
      </StyledMatchWrapperSection>
      <Navigation />
    </StyledDiv>
  );
}

const StyledDiv = styled.div`
  height: 100dvh;
  width: 100dvw;
  padding: 0;
  font-size: 20px;
  font-family: baloo_2;
  position: relative;
  overflow: hidden;
  background-color: black;
`;

const StyledUl = styled.ul`
  list-style-type: none;
`;

const StyledP = styled.p`
  color: white;
  margin-left: 1rem;
`;

const StyledMatchWrapperSection = styled.section`
  border: 1px solid white;
  height: 65dvh;
  width: 100dvw;
  margin-top: -1rem;
  overflow: scroll;
`;

const StyledMatch = styled.li`
  position: relative;
  width: 50dvw;
  margin-top: 1rem;
  /* From https://css.glass */
  background: rgba(255, 255, 255, 0.2);
  border-radius: 16px;
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(5px);
  border: 1px solid rgba(255, 255, 255, 0.3);
`;
